# Функция - это блок кода, который можно вызывать с разными параметрами
# Функции - молотилки данных - внутрь помещаете значения, наа выходе получаете результат

employees_1 = {
    'Alice' : 100000,
    'Bob' : 99817,
    'Carol' : 122988,
    'Frank' : 88123,
    'Eve' : 93121
    }
employees_2 = {
    'Nikita' : 1,
    'Masha' : 110000,
    'Matvey' : 90000,
    'Sasha' : 88123,
    'Tahya' : 193121
    }

# Этап создания функции
def get_topmgrs(empl):
    return [n for n, s in empl.items() if s >= 100000] # совмещение for и if 
    
# Этап вызова функции
get_topmgrs(employees_1)
get_topmgrs(employees_2)


# Воспользуемся результатом работы функции
print([employees_1[i]*1.5 for i in get_topmgrs(employees_1)])

# Подробнее о функциях
# при отладке интерпретатор записывает имя функции и при вызове возвращается в нее
# Этап создания функции
# добавим параметры функции (name) - данные на входе, которые  нужно обработать внутри функции
def greeting(name):
    # Локальное пространство имен
    print('Привет,', name)

# Этап вызова функции
# Глобальное пространство имен
names = ['Мария', 'Матвей', 'Никита', 'Любовь']
for i in names:
    greeting(i)
# на выходе будет -> 
# Привет, Мария
# Привет, Матвей
# Привет, Никита
# Привет, Любовь

# Хотелось бы в дальнейшем эту функцию (greeting(i)) использовать  ->
# вернемся к задаче про employees в самом верху


###################################################################################################


# Решение задачи с помощью функции
# Функции - молотилки данных - внутрь помещаете значения, наа выходе получаете результат
# изначально вместо return было print, и при вызове тоже получим ответ
# но, если мы хотим воспользоваться результатом функции (чтобы применить в работе)
# мы на входе передаем данные, а на выходе хотим получить другие данные
# Пример: функция деления принимает div (х - делимое, у - делитель) -> z - частное
# Но еслимы выведем print на экран, то он ответа не даст, не зафиксируется.
employees_1 = {
    'Alice' : 100000,
    'Bob' : 99817,
    'Carol' : 122988,
    'Frank' : 88123,
    'Eve' : 93121
    }
employees_2 = {
    'Nikita' : 1,
    'Masha' : 110000,
    'Matvey' : 90000,
    'Sasha' : 88123,
    'Tahya' : 193121
    }

# Этап создания функции
# чтобы вернуть результат работы функции необходимо использовать return
# return Npne
# что не устраивает? Мы должны получить список и куда-то его применить.
# Поэтому пишем не print, а return 
# а print можем использовать, если хотим посмотреть рез-т той или иной операции

def get_topmgrs(empl):
    print ([n for n, s in empl.items() if s >= 100000]) # совмещение for и if 
# return None

# Этап вызова функции
print(
    get_topmgrs(employees_1),
    get_topmgrs(employees_2)
    )

# Воспользуемся результатом работы функции
# чтобы вернуть результат работы функции необходимо использовать return
print([employees_1[i]*1.5 for i in get_topmgrs(employees_1)])


###########################################################################################

# функция, которая возвращает несколько значений
def add_root():          # функция добавляет пользователя
    name = 'root'        # определяет имя name  -> root
    uid = 0              # идентификатор юзера
    return name, uid     # возвращаем из этой функции имя и uid
# если напишем print(add_root())
print(add_root())        # ('root', 0). Получим кортеж
# теперь необходимо кортеж распаковать
user_name, user_uid -add_root()    # ('root', 0)

# Форматированный вывод строк
# Варианты вывода строк в консоль

# 1 вариант через print
print ('Имя пользоватея -', user_name, 'UID пользователя', user_uid)
# print ('Имя пользоватея -' + user_name + 'UID пользователя' + user_uid)

# 2 вариант через метод format
print(
    'Имя пользоватея - {}UID пользователя - {}'.format(user_name, user_uid)
)
# пример применения
# url = 'http://www.ranepa.ru/profile/login={}'.format('nikname')
# если переменных много, то
# пример применения
# url = 'http://www.ranepa.ru/profile/login={}&passwd={}&param={}&method={}'.format(login_name, pswd, prm, mthd)
# неудобно, когда много переменных, хочется сразу вставлятьэти имена - это3 способ

# 3 способ через f строки
print (
    f'Имя пользоватея - {user_name}\nUID пользователя - {user_uid}'
    )
# крайне удобный способ
# пример применения
# url = f'http://www.ranepa.ru/profile/login={login_name}&passwd={pswd}&param={prm}&method={mthd}'

#######################################################################################################################


# Подробнее о функциях
# если навести на любую функцию, то увидим подробное описание
#   например, print
        # как добавить описание? ОК
        # какие типы данных можно передать в параметры?
        # именованные и позиционные параметры?
        # чему равен параметр по умолчанию?
        # что такое "value"?

# функция деления принимает div (х - делимое, у - делитель) -> z - частное
# 25 // 5 == 5
def divide(dividend: int, divisor: int) -> int:
    """
    Функция divide принимает делимое и делитель в качестве параметров
    и возвращат целое частное
    """
    quotient = 0

    while dividend > 0:
        dividend -= divisor
        quotient += 1

    return quotient

print('Разультат деления:', divide(25, 5))
# на выходе будет - Результат деления: 5
    
'''
Функция divide принимает делимое и делитель в качестве параметров
и возвращат целое частное
dividend - делимое
divisor - делитель
quatient - частное
'''
# именованные и позиционные параметры
# параметры по умолчанию
# явный вызов именованных параметров

def trapezoid_s(a, b, *, h=1): # * - это явный именованный параметр,
    return h * (a+b) / 2
# означает, что все значения * после него, должны быть именованные
'''Функция для расчета площади трапеции. a - нижнее основание, b - верхнее основание, h - высота'''

S = trapezoid_s(4, 6)
S = trapezoid_s(4, 6, h=10) # именованные параметры - h=10
print(S)

# име6нованные параметры можно изменять и можно не выводить    
# Произвольное число параметров
# print(1, 2, 3, 4, 5, 'Hello', []], []])
# ПРАВИЛО: сначала ставят именованные, потом позиционные
# print(sum_all(1, 2, 3, 4, 5, 100))
def sum_all(*args):    # запаковка параметров
    # args - это кортеж
    total = 0
    for i in args:
        total += i
    return total

print(sum_all(1, 2, 3, 4, 5, 100))

# Произвольное число параметров
# print(1, 2, 3, 4, 5,  'hello, [[], []]')
def sum_all(*args):
    # args - кортеж    total = 0
    for i in args:
       total += i
    return total
print(sum_chil)

print(sum_all(1, 2, 3, 4, 5, 50, ))
# это все запаковка параметров  
    
################################################################################################

# # top_mgrs = [n for n, s in employees_1.items() if s >= 100000] # совмещение for и if 
# # top_mgrs = [n for n, s in employees_2.items() if s >= 100000] # совмещение for и if 
# # print(top_mgrs) 
# # при отладке интерпретатор записываеи имя функции и при вызове возвращается в нее
# # этап создания функции
# # параметры функции - данные на входе, которые нужно обработать внутри
# def greeting(name):
#     # Локальное пространство имен
#     print('Привет', name)

# # этап вызова функции
# # Глобальное пространство имен

#############################################################